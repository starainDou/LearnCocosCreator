{
  "__type__": "cc.TextAsset",
  "_name": "bignumber.d",
  "_objFlags": 0,
  "_native": "",
  "text": "// Type definitions for bignumber.js >=8.1.0\r\n// Project: https://github.com/MikeMcl/bignumber.js\r\n// Definitions by: Michael Mclaughlin <https://github.com/MikeMcl>\r\n// Definitions: https://github.com/MikeMcl/bignumber.js\r\n\r\n// Documentation: http://mikemcl.github.io/bignumber.js/\r\n//\r\n// Exports:\r\n//\r\n//   class     BigNumber (default export)\r\n//   type      BigNumber.Constructor\r\n//   type      BigNumber.ModuloMode\r\n//   type      BigNumber.RoundingMode\r\n//   type      BigNumber.Value\r\n//   interface BigNumber.Config\r\n//   interface BigNumber.Format\r\n//   interface BigNumber.Instance\r\n//\r\n// Example:\r\n//\r\n//   import {BigNumber} from \"bignumber.js\"\r\n//   //import BigNumber from \"bignumber.js\"\r\n//\r\n//   let rm: BigNumber.RoundingMode = BigNumber.ROUND_UP;\r\n//   let f: BigNumber.Format = { decimalSeparator: ',' };\r\n//   let c: BigNumber.Config = { DECIMAL_PLACES: 4, ROUNDING_MODE: rm, FORMAT: f };\r\n//   BigNumber.config(c);\r\n//\r\n//   let v: BigNumber.Value = '12345.6789';\r\n//   let b: BigNumber = new BigNumber(v);\r\n//\r\n// The use of compiler option `--strictNullChecks` is recommended.\r\n\r\nexport default BigNumber;\r\n\r\nexport namespace BigNumber {\r\n\r\n  /** See `BigNumber.config` (alias `BigNumber.set`) and `BigNumber.clone`. */\r\n  interface Config {\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9. Default value: 20.\r\n     *\r\n     * The maximum number of decimal places of the result of operations involving division, i.e.\r\n     * division, square root and base conversion operations, and exponentiation when the exponent is\r\n     * negative.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n     * BigNumber.set({ DECIMAL_PLACES: 5 })\r\n     * ```\r\n     */\r\n    DECIMAL_PLACES?: number;\r\n\r\n    /**\r\n     * An integer, 0 to 8. Default value: `BigNumber.ROUND_HALF_UP` (4).\r\n     *\r\n     * The rounding mode used in operations that involve division (see `DECIMAL_PLACES`) and the\r\n     * default rounding mode of the `decimalPlaces`, `precision`, `toExponential`, `toFixed`,\r\n     * `toFormat` and `toPrecision` methods.\r\n     *\r\n     * The modes are available as enumerated properties of the BigNumber constructor.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ ROUNDING_MODE: 0 })\r\n     * BigNumber.set({ ROUNDING_MODE: BigNumber.ROUND_UP })\r\n     * ```\r\n     */\r\n    ROUNDING_MODE?: BigNumber.RoundingMode;\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9, or an array, [-1e+9 to 0, 0 to 1e+9].\r\n     * Default value: `[-7, 20]`.\r\n     *\r\n     * The exponent value(s) at which `toString` returns exponential notation.\r\n     *\r\n     * If a single number is assigned, the value is the exponent magnitude.\r\n     *\r\n     * If an array of two numbers is assigned then the first number is the negative exponent value at\r\n     * and beneath which exponential notation is used, and the second number is the positive exponent\r\n     * value at and above which exponential notation is used.\r\n     *\r\n     * For example, to emulate JavaScript numbers in terms of the exponent values at which they begin\r\n     * to use exponential notation, use `[-7, 20]`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ EXPONENTIAL_AT: 2 })\r\n     * new BigNumber(12.3)         // '12.3'        e is only 1\r\n     * new BigNumber(123)          // '1.23e+2'\r\n     * new BigNumber(0.123)        // '0.123'       e is only -1\r\n     * new BigNumber(0.0123)       // '1.23e-2'\r\n     *\r\n     * BigNumber.config({ EXPONENTIAL_AT: [-7, 20] })\r\n     * new BigNumber(123456789)    // '123456789'   e is only 8\r\n     * new BigNumber(0.000000123)  // '1.23e-7'\r\n     *\r\n     * // Almost never return exponential notation:\r\n     * BigNumber.config({ EXPONENTIAL_AT: 1e+9 })\r\n     *\r\n     * // Always return exponential notation:\r\n     * BigNumber.config({ EXPONENTIAL_AT: 0 })\r\n     * ```\r\n     *\r\n     * Regardless of the value of `EXPONENTIAL_AT`, the `toFixed` method will always return a value in\r\n     * normal notation and the `toExponential` method will always return a value in exponential form.\r\n     * Calling `toString` with a base argument, e.g. `toString(10)`, will also always return normal\r\n     * notation.\r\n     */\r\n    EXPONENTIAL_AT?: number | [number, number];\r\n\r\n    /**\r\n     * An integer, magnitude 1 to 1e+9, or an array, [-1e+9 to -1, 1 to 1e+9].\r\n     * Default value: `[-1e+9, 1e+9]`.\r\n     *\r\n     * The exponent value(s) beyond which overflow to Infinity and underflow to zero occurs.\r\n     *\r\n     * If a single number is assigned, it is the maximum exponent magnitude: values wth a positive\r\n     * exponent of greater magnitude become Infinity and those with a negative exponent of greater\r\n     * magnitude become zero.\r\n     *\r\n     * If an array of two numbers is assigned then the first number is the negative exponent limit and\r\n     * the second number is the positive exponent limit.\r\n     *\r\n     * For example, to emulate JavaScript numbers in terms of the exponent values at which they\r\n     * become zero and Infinity, use [-324, 308].\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ RANGE: 500 })\r\n     * BigNumber.config().RANGE     // [ -500, 500 ]\r\n     * new BigNumber('9.999e499')   // '9.999e+499'\r\n     * new BigNumber('1e500')       // 'Infinity'\r\n     * new BigNumber('1e-499')      // '1e-499'\r\n     * new BigNumber('1e-500')      // '0'\r\n     *\r\n     * BigNumber.config({ RANGE: [-3, 4] })\r\n     * new BigNumber(99999)         // '99999'      e is only 4\r\n     * new BigNumber(100000)        // 'Infinity'   e is 5\r\n     * new BigNumber(0.001)         // '0.01'       e is only -3\r\n     * new BigNumber(0.0001)        // '0'          e is -4\r\n     * ```\r\n     * The largest possible magnitude of a finite BigNumber is 9.999...e+1000000000.\r\n     * The smallest possible magnitude of a non-zero BigNumber is 1e-1000000000.\r\n     */\r\n    RANGE?: number | [number, number];\r\n\r\n    /**\r\n     * A boolean: `true` or `false`. Default value: `false`.\r\n     *\r\n     * The value that determines whether cryptographically-secure pseudo-random number generation is\r\n     * used. If `CRYPTO` is set to true then the random method will generate random digits using\r\n     * `crypto.getRandomValues` in browsers that support it, or `crypto.randomBytes` if using a\r\n     * version of Node.js that supports it.\r\n     *\r\n     * If neither function is supported by the host environment then attempting to set `CRYPTO` to\r\n     * `true` will fail and an exception will be thrown.\r\n     *\r\n     * If `CRYPTO` is `false` then the source of randomness used will be `Math.random` (which is\r\n     * assumed to generate at least 30 bits of randomness).\r\n     *\r\n     * See `BigNumber.random`.\r\n     *\r\n     * ```ts\r\n     * // Node.js\r\n     * global.crypto = require('crypto')\r\n     *\r\n     * BigNumber.config({ CRYPTO: true })\r\n     * BigNumber.config().CRYPTO       // true\r\n     * BigNumber.random()              // 0.54340758610486147524\r\n     * ```\r\n     */\r\n    CRYPTO?: boolean;\r\n\r\n    /**\r\n     * An integer, 0, 1, 3, 6 or 9. Default value: `BigNumber.ROUND_DOWN` (1).\r\n     *\r\n     * The modulo mode used when calculating the modulus: `a mod n`.\r\n     * The quotient, `q = a / n`, is calculated according to the `ROUNDING_MODE` that corresponds to\r\n     * the chosen `MODULO_MODE`.\r\n     * The remainder, `r`, is calculated as: `r = a - n * q`.\r\n     *\r\n     * The modes that are most commonly used for the modulus/remainder operation are shown in the\r\n     * following table. Although the other rounding modes can be used, they may not give useful\r\n     * results.\r\n     *\r\n     * Property           | Value | Description\r\n     * :------------------|:------|:------------------------------------------------------------------\r\n     *  `ROUND_UP`        |   0   | The remainder is positive if the dividend is negative.\r\n     *  `ROUND_DOWN`      |   1   | The remainder has the same sign as the dividend.\r\n     *                    |       | Uses 'truncating division' and matches JavaScript's `%` operator .\r\n     *  `ROUND_FLOOR`     |   3   | The remainder has the same sign as the divisor.\r\n     *                    |       | This matches Python's `%` operator.\r\n     *  `ROUND_HALF_EVEN` |   6   | The IEEE 754 remainder function.\r\n     *  `EUCLID`          |   9   | The remainder is always positive.\r\n     *                    |       | Euclidian division: `q = sign(n) * floor(a / abs(n))`\r\n     *\r\n     * The rounding/modulo modes are available as enumerated properties of the BigNumber constructor.\r\n     *\r\n     * See `modulo`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ MODULO_MODE: BigNumber.EUCLID })\r\n     * BigNumber.set({ MODULO_MODE: 9 })          // equivalent\r\n     * ```\r\n     */\r\n    MODULO_MODE?: BigNumber.ModuloMode;\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9. Default value: 0.\r\n     *\r\n     * The maximum precision, i.e. number of significant digits, of the result of the power operation\r\n     * - unless a modulus is specified.\r\n     *\r\n     * If set to 0, the number of significant digits will not be limited.\r\n     *\r\n     * See `exponentiatedBy`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ POW_PRECISION: 100 })\r\n     * ```\r\n     */\r\n    POW_PRECISION?: number;\r\n\r\n    /**\r\n     * An object including any number of the properties shown below.\r\n     *\r\n     * The object configures the format of the string returned by the `toFormat` method.\r\n     * The example below shows the properties of the object that are recognised, and\r\n     * their default values.\r\n     *\r\n     * Unlike the other configuration properties, the values of the properties of the `FORMAT` object\r\n     * will not be checked for validity - the existing object will simply be replaced by the object\r\n     * that is passed in.\r\n     *\r\n     * See `toFormat`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({\r\n     *   FORMAT: {\r\n     *     // string to prepend\r\n     *     prefix: '',\r\n     *     // the decimal separator\r\n     *     decimalSeparator: '.',\r\n     *     // the grouping separator of the integer part\r\n     *     groupSeparator: ',',\r\n     *     // the primary grouping size of the integer part\r\n     *     groupSize: 3,\r\n     *     // the secondary grouping size of the integer part\r\n     *     secondaryGroupSize: 0,\r\n     *     // the grouping separator of the fraction part\r\n     *     fractionGroupSeparator: ' ',\r\n     *     // the grouping size of the fraction part\r\n     *     fractionGroupSize: 0,\r\n     *     // string to append\r\n     *     suffix: ''\r\n     *   }\r\n     * })\r\n     * ```\r\n     */\r\n    FORMAT?: BigNumber.Format;\r\n\r\n    /**\r\n     * The alphabet used for base conversion. The length of the alphabet corresponds to the maximum\r\n     * value of the base argument that can be passed to the BigNumber constructor or `toString`.\r\n     *\r\n     * Default value: `'0123456789abcdefghijklmnopqrstuvwxyz'`.\r\n     *\r\n     * There is no maximum length for the alphabet, but it must be at least 2 characters long,\r\n     * and it must not contain whitespace or a repeated character, or the sign indicators '+' and\r\n     * '-', or the decimal separator '.'.\r\n     *\r\n     * ```ts\r\n     * // duodecimal (base 12)\r\n     * BigNumber.config({ ALPHABET: '0123456789TE' })\r\n     * x = new BigNumber('T', 12)\r\n     * x.toString()                // '10'\r\n     * x.toString(12)              // 'T'\r\n     * ```\r\n     */\r\n    ALPHABET?: string;\r\n  }\r\n\r\n  /** See `FORMAT` and `toFormat`. */\r\n  interface Format {\r\n\r\n    /** The string to prepend. */\r\n    prefix?: string;\r\n\r\n    /** The decimal separator. */\r\n    decimalSeparator?: string;\r\n\r\n    /** The grouping separator of the integer part. */\r\n    groupSeparator?: string;\r\n\r\n    /** The primary grouping size of the integer part. */\r\n    groupSize?: number;\r\n\r\n    /** The secondary grouping size of the integer part. */\r\n    secondaryGroupSize?: number;\r\n\r\n    /** The grouping separator of the fraction part. */\r\n    fractionGroupSeparator?: string;\r\n\r\n    /** The grouping size of the fraction part. */\r\n    fractionGroupSize?: number;\r\n\r\n    /** The string to append. */\r\n    suffix?: string;\r\n  }\r\n\r\n  interface Instance {\r\n\r\n    /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */\r\n    readonly c: number[] | null;\r\n\r\n    /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */\r\n    readonly e: number | null;\r\n\r\n    /** The sign of the value of this BigNumber, -1, 1, or null. */\r\n    readonly s: number | null;\r\n\r\n    [key: string]: any;\r\n  }\r\n\r\n  type Constructor = typeof BigNumber;\r\n  type ModuloMode = 0 | 1 | 3 | 6 | 9;\r\n  type RoundingMode = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n  type Value = string | number | Instance;\r\n}\r\n\r\nexport declare class BigNumber implements BigNumber.Instance {\r\n\r\n  /** Used internally to identify a BigNumber instance. */\r\n  private readonly _isBigNumber: true;\r\n\r\n  /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */\r\n  readonly c: number[] | null;\r\n\r\n  /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */\r\n  readonly e: number | null;\r\n\r\n  /** The sign of the value of this BigNumber, -1, 1, or null. */\r\n  readonly s: number | null;\r\n\r\n  /**\r\n   * Returns a new instance of a BigNumber object with value `n`, where `n` is a numeric value in\r\n   * the specified `base`, or base 10 if `base` is omitted or is `null` or `undefined`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(123.4567)              // '123.4567'\r\n   * // 'new' is optional\r\n   * y = BigNumber(x)                         // '123.4567'\r\n   * ```\r\n   *\r\n   * If `n` is a base 10 value it can be in normal (fixed-point) or exponential notation.\r\n   * Values in other bases must be in normal notation. Values in any base can have fraction digits,\r\n   * i.e. digits after the decimal point.\r\n   *\r\n   * ```ts\r\n   * new BigNumber(43210)                     // '43210'\r\n   * new BigNumber('4.321e+4')                // '43210'\r\n   * new BigNumber('-735.0918e-430')          // '-7.350918e-428'\r\n   * new BigNumber('123412421.234324', 5)     // '607236.557696'\r\n   * ```\r\n   *\r\n   * Signed `0`, signed `Infinity` and `NaN` are supported.\r\n   *\r\n   * ```ts\r\n   * new BigNumber('-Infinity')               // '-Infinity'\r\n   * new BigNumber(NaN)                       // 'NaN'\r\n   * new BigNumber(-0)                        // '0'\r\n   * new BigNumber('.5')                      // '0.5'\r\n   * new BigNumber('+2')                      // '2'\r\n   * ```\r\n   *\r\n   * String values in hexadecimal literal form, e.g. `'0xff'`, are valid, as are string values with\r\n   * the octal and binary prefixs `'0o'` and `'0b'`. String values in octal literal form without the\r\n   * prefix will be interpreted as decimals, e.g. `'011'` is interpreted as 11, not 9.\r\n   *\r\n   * ```ts\r\n   * new BigNumber(-10110100.1, 2)            // '-180.5'\r\n   * new BigNumber('-0b10110100.1')           // '-180.5'\r\n   * new BigNumber('ff.8', 16)                // '255.5'\r\n   * new BigNumber('0xff.8')                  // '255.5'\r\n   * ```\r\n   *\r\n   * If a base is specified, `n` is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings. This includes base 10, so don't include a `base` parameter for decimal\r\n   * values unless this behaviour is desired.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n   * new BigNumber(1.23456789)                // '1.23456789'\r\n   * new BigNumber(1.23456789, 10)            // '1.23457'\r\n   * ```\r\n   *\r\n   * An error is thrown if `base` is invalid.\r\n   *\r\n   * There is no limit to the number of digits of a value of type string (other than that of\r\n   * JavaScript's maximum array size). See `RANGE` to set the maximum and minimum possible exponent\r\n   * value of a BigNumber.\r\n   *\r\n   * ```ts\r\n   * new BigNumber('5032485723458348569331745.33434346346912144534543')\r\n   * new BigNumber('4.321e10000000')\r\n   * ```\r\n   *\r\n   * BigNumber `NaN` is returned if `n` is invalid (unless `BigNumber.DEBUG` is `true`, see below).\r\n   *\r\n   * ```ts\r\n   * new BigNumber('.1*')                    // 'NaN'\r\n   * new BigNumber('blurgh')                 // 'NaN'\r\n   * new BigNumber(9, 2)                     // 'NaN'\r\n   * ```\r\n   *\r\n   * To aid in debugging, if `BigNumber.DEBUG` is `true` then an error will be thrown on an\r\n   * invalid `n`. An error will also be thrown if `n` is of type number with more than 15\r\n   * significant digits, as calling `toString` or `valueOf` on these numbers may not result in the\r\n   * intended value.\r\n   *\r\n   * ```ts\r\n   * console.log(823456789123456.3)          //  823456789123456.2\r\n   * new BigNumber(823456789123456.3)        // '823456789123456.2'\r\n   * BigNumber.DEBUG = true\r\n   * // 'Error: Number has more than 15 significant digits'\r\n   * new BigNumber(823456789123456.3)\r\n   * // 'Error: Not a base 2 number'\r\n   * new BigNumber(9, 2)\r\n   * ```\r\n   *\r\n   * A BigNumber can also be created from an object literal.\r\n   * Use `isBigNumber` to check that it is well-formed.\r\n   *\r\n   * ```ts\r\n   * new BigNumber({ s: 1, e: 2, c: [ 777, 12300000000000 ], _isBigNumber: true })    // '777.123'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param base The base of `n`, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).\r\n   */\r\n  constructor(n: BigNumber.Value, base?: number);\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this\r\n   * BigNumber.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0.8)\r\n   * x.absoluteValue()           // '0.8'\r\n   * ```\r\n   */\r\n  absoluteValue(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this\r\n   * BigNumber.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0.8)\r\n   * x.abs()                     // '0.8'\r\n   * ```\r\n   */\r\n  abs(): BigNumber;\r\n\r\n  /**\r\n   *  Returns |                                                               |\r\n   * :-------:|:--------------------------------------------------------------|\r\n   *     1    | If the value of this BigNumber is greater than the value of `n`\r\n   *    -1    | If the value of this BigNumber is less than the value of `n`\r\n   *     0    | If this BigNumber and `n` have the same value\r\n   *  `null`  | If the value of either this BigNumber or `n` is `NaN`\r\n   *\r\n   * ```ts\r\n   *\r\n   * x = new BigNumber(Infinity)\r\n   * y = new BigNumber(5)\r\n   * x.comparedTo(y)                 // 1\r\n   * x.comparedTo(x.minus(1))        // 0\r\n   * y.comparedTo(NaN)               // null\r\n   * y.comparedTo('110', 2)          // -1\r\n   * ```\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  comparedTo(n: BigNumber.Value, base?: number): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode\r\n   * `roundingMode` to a maximum of `decimalPlaces` decimal places.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of\r\n   * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is\r\n   * ±`Infinity` or `NaN`.\r\n   *\r\n   * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1234.56)\r\n   * x.decimalPlaces()                      // 2\r\n   * x.decimalPlaces(1)                     // '1234.6'\r\n   * x.decimalPlaces(2)                     // '1234.56'\r\n   * x.decimalPlaces(10)                    // '1234.56'\r\n   * x.decimalPlaces(0, 1)                  // '1234'\r\n   * x.decimalPlaces(0, 6)                  // '1235'\r\n   * x.decimalPlaces(1, 1)                  // '1234.5'\r\n   * x.decimalPlaces(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'\r\n   * x                                      // '1234.56'\r\n   * y = new BigNumber('9.9e-101')\r\n   * y.decimalPlaces()                      // 102\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  decimalPlaces(): number | null;\r\n  decimalPlaces(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode\r\n   * `roundingMode` to a maximum of `decimalPlaces` decimal places.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of\r\n   * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is\r\n   * ±`Infinity` or `NaN`.\r\n   *\r\n   * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1234.56)\r\n   * x.dp()                                 // 2\r\n   * x.dp(1)                                // '1234.6'\r\n   * x.dp(2)                                // '1234.56'\r\n   * x.dp(10)                               // '1234.56'\r\n   * x.dp(0, 1)                             // '1234'\r\n   * x.dp(0, 6)                             // '1235'\r\n   * x.dp(1, 1)                             // '1234.5'\r\n   * x.dp(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'\r\n   * x                                      // '1234.56'\r\n   * y = new BigNumber('9.9e-101')\r\n   * y.dp()                                 // 102\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  dp(): number | null;\r\n  dp(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(355)\r\n   * y = new BigNumber(113)\r\n   * x.dividedBy(y)                  // '3.14159292035398230088'\r\n   * x.dividedBy(5)                  // '71'\r\n   * x.dividedBy(47, 16)             // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  dividedBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(355)\r\n   * y = new BigNumber(113)\r\n   * x.div(y)                    // '3.14159292035398230088'\r\n   * x.div(5)                    // '71'\r\n   * x.div(47, 16)               // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  div(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by\r\n   * `n`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(5)\r\n   * y = new BigNumber(3)\r\n   * x.dividedToIntegerBy(y)              // '1'\r\n   * x.dividedToIntegerBy(0.7)            // '7'\r\n   * x.dividedToIntegerBy('0.f', 16)      // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  dividedToIntegerBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by\r\n   * `n`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(5)\r\n   * y = new BigNumber(3)\r\n   * x.idiv(y)                       // '1'\r\n   * x.idiv(0.7)                     // '7'\r\n   * x.idiv('0.f', 16)               // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  idiv(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.\r\n   * raised to the power `n`, and optionally modulo a modulus `m`.\r\n   *\r\n   * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings.\r\n   *\r\n   * As the number of digits of the result of the power operation can grow so large so quickly,\r\n   * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is\r\n   * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).\r\n   *\r\n   * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant\r\n   * digits will be calculated, and that the method's performance will decrease dramatically for\r\n   * larger exponents.\r\n   *\r\n   * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is\r\n   * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will\r\n   * be performed as `x.exponentiatedBy(n).modulo(m)` with a `POW_PRECISION` of 0.\r\n   *\r\n   * Throws if `n` is not an integer.\r\n   *\r\n   * ```ts\r\n   * Math.pow(0.7, 2)                    // 0.48999999999999994\r\n   * x = new BigNumber(0.7)\r\n   * x.exponentiatedBy(2)                // '0.49'\r\n   * BigNumber(3).exponentiatedBy(-2)    // '0.11111111111111111111'\r\n   * ```\r\n   *\r\n   * @param n The exponent, an integer.\r\n   * @param [m] The modulus.\r\n   */\r\n  exponentiatedBy(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;\r\n  exponentiatedBy(n: number, m?: BigNumber.Value): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.\r\n   * raised to the power `n`, and optionally modulo a modulus `m`.\r\n   *\r\n   * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings.\r\n   *\r\n   * As the number of digits of the result of the power operation can grow so large so quickly,\r\n   * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is\r\n   * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).\r\n   *\r\n   * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant\r\n   * digits will be calculated, and that the method's performance will decrease dramatically for\r\n   * larger exponents.\r\n   *\r\n   * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is\r\n   * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will\r\n   * be performed as `x.pow(n).modulo(m)` with a `POW_PRECISION` of 0.\r\n   *\r\n   * Throws if `n` is not an integer.\r\n   *\r\n   * ```ts\r\n   * Math.pow(0.7, 2)                   // 0.48999999999999994\r\n   * x = new BigNumber(0.7)\r\n   * x.pow(2)                           // '0.49'\r\n   * BigNumber(3).pow(-2)               // '0.11111111111111111111'\r\n   * ```\r\n   *\r\n   * @param n The exponent, an integer.\r\n   * @param [m] The modulus.\r\n   */\r\n  pow(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;\r\n  pow(n: number, m?: BigNumber.Value): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to an integer using\r\n   * rounding mode `rm`.\r\n   *\r\n   * If `rm` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `rm` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(123.456)\r\n   * x.integerValue()                        // '123'\r\n   * x.integerValue(BigNumber.ROUND_CEIL)    // '124'\r\n   * y = new BigNumber(-12.7)\r\n   * y.integerValue()                        // '-13'\r\n   * x.integerValue(BigNumber.ROUND_DOWN)    // '-12'\r\n   * ```\r\n   *\r\n   * @param {BigNumber.RoundingMode} [rm] The roundng mode, an integer, 0 to 8.\r\n   */\r\n  integerValue(rm?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * As with JavaScript, `NaN` does not equal `NaN`.\r\n   *\r\n   * ```ts\r\n   * 0 === 1e-324                           // true\r\n   * x = new BigNumber(0)\r\n   * x.isEqualTo('1e-324')                  // false\r\n   * BigNumber(-0).isEqualTo(x)             // true  ( -0 === 0 )\r\n   * BigNumber(255).isEqualTo('ff', 16)     // true\r\n   *\r\n   * y = new BigNumber(NaN)\r\n   * y.isEqualTo(NaN)                // false\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * As with JavaScript, `NaN` does not equal `NaN`.\r\n   *\r\n   * ```ts\r\n   * 0 === 1e-324                    // true\r\n   * x = new BigNumber(0)\r\n   * x.eq('1e-324')                  // false\r\n   * BigNumber(-0).eq(x)             // true  ( -0 === 0 )\r\n   * BigNumber(255).eq('ff', 16)     // true\r\n   *\r\n   * y = new BigNumber(NaN)\r\n   * y.eq(NaN)                       // false\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  eq(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is a finite number, otherwise returns `false`.\r\n   *\r\n   * The only possible non-finite values of a BigNumber are `NaN`, `Infinity` and `-Infinity`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1)\r\n   * x.isFinite()                    // true\r\n   * y = new BigNumber(Infinity)\r\n   * y.isFinite()                    // false\r\n   * ```\r\n   */\r\n  isFinite(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise\r\n   * returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 > (0.3 - 0.2)                             // true\r\n   * x = new BigNumber(0.1)\r\n   * x.isGreaterThan(BigNumber(0.3).minus(0.2))    // false\r\n   * BigNumber(0).isGreaterThan(x)                 // false\r\n   * BigNumber(11, 3).isGreaterThan(11.1, 2)       // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isGreaterThan(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise\r\n   * returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 > (0.3 - 0                     // true\r\n   * x = new BigNumber(0.1)\r\n   * x.gt(BigNumber(0.3).minus(0.2))    // false\r\n   * BigNumber(0).gt(x)                 // false\r\n   * BigNumber(11, 3).gt(11.1, 2)       // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  gt(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) >= 0.1                                  // false\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.isGreaterThanOrEqualTo(0.1)                       // true\r\n   * BigNumber(1).isGreaterThanOrEqualTo(x)              // true\r\n   * BigNumber(10, 18).isGreaterThanOrEqualTo('i', 36)   // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isGreaterThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) >= 0.1                    // false\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.gte(0.1)                            // true\r\n   * BigNumber(1).gte(x)                   // true\r\n   * BigNumber(10, 18).gte('i', 36)        // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  gte(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is an integer, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1)\r\n   * x.isInteger()                   // true\r\n   * y = new BigNumber(123.456)\r\n   * y.isInteger()                   // false\r\n   * ```\r\n   */\r\n  isInteger(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) < 0.1                       // true\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.isLessThan(0.1)                       // false\r\n   * BigNumber(0).isLessThan(x)              // true\r\n   * BigNumber(11.1, 2).isLessThan(11, 3)    // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isLessThan(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) < 0.1                       // true\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.lt(0.1)                               // false\r\n   * BigNumber(0).lt(x)                      // true\r\n   * BigNumber(11.1, 2).lt(11, 3)            // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  lt(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 <= (0.3 - 0.2)                                 // false\r\n   * x = new BigNumber(0.1)\r\n   * x.isLessThanOrEqualTo(BigNumber(0.3).minus(0.2))   // true\r\n   * BigNumber(-1).isLessThanOrEqualTo(x)               // true\r\n   * BigNumber(10, 18).isLessThanOrEqualTo('i', 36)     // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isLessThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 <= (0.3 - 0.2)                  // false\r\n   * x = new BigNumber(0.1)\r\n   * x.lte(BigNumber(0.3).minus(0.2))    // true\r\n   * BigNumber(-1).lte(x)                // true\r\n   * BigNumber(10, 18).lte('i', 36)      // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  lte(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is `NaN`, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(NaN)\r\n   * x.isNaN()                       // true\r\n   * y = new BigNumber('Infinity')\r\n   * y.isNaN()                       // false\r\n   * ```\r\n   */\r\n  isNaN(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is negative, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isNegative()                  // true\r\n   * y = new BigNumber(2)\r\n   * y.isNegative()                  // false\r\n   * ```\r\n   */\r\n  isNegative(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is positive, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isPositive()                  // false\r\n   * y = new BigNumber(2)\r\n   * y.isPositive()                  // true\r\n   * ```\r\n   */\r\n  isPositive(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is zero or minus zero, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isZero()                 // true\r\n   * ```\r\n   */\r\n  isZero(): boolean;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber minus `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.3 - 0.1                       // 0.19999999999999998\r\n   * x = new BigNumber(0.3)\r\n   * x.minus(0.1)                    // '0.2'\r\n   * x.minus(0.6, 20)                // '0'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  minus(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer\r\n   * remainder of dividing this BigNumber by `n`.\r\n   *\r\n   * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`\r\n   * setting of this BigNumber constructor. If it is 1 (default value), the result will have the\r\n   * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the\r\n   * limits of double precision) and BigDecimal's `remainder` method.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * See `MODULO_MODE` for a description of the other modulo modes.\r\n   *\r\n   * ```ts\r\n   * 1 % 0.9                         // 0.09999999999999998\r\n   * x = new BigNumber(1)\r\n   * x.modulo(0.9)                   // '0.1'\r\n   * y = new BigNumber(33)\r\n   * y.modulo('a', 33)               // '3'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  modulo(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer\r\n   * remainder of dividing this BigNumber by `n`.\r\n   *\r\n   * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`\r\n   * setting of this BigNumber constructor. If it is 1 (default value), the result will have the\r\n   * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the\r\n   * limits of double precision) and BigDecimal's `remainder` method.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * See `MODULO_MODE` for a description of the other modulo modes.\r\n   *\r\n   * ```ts\r\n   * 1 % 0.9                      // 0.09999999999999998\r\n   * x = new BigNumber(1)\r\n   * x.mod(0.9)                   // '0.1'\r\n   * y = new BigNumber(33)\r\n   * y.mod('a', 33)               // '3'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  mod(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.6 * 3                                // 1.7999999999999998\r\n   * x = new BigNumber(0.6)\r\n   * y = x.multipliedBy(3)                  // '1.8'\r\n   * BigNumber('7e+500').multipliedBy(y)    // '1.26e+501'\r\n   * x.multipliedBy('-a', 16)               // '-6'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  multipliedBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.6 * 3                         // 1.7999999999999998\r\n   * x = new BigNumber(0.6)\r\n   * y = x.times(3)                  // '1.8'\r\n   * BigNumber('7e+500').times(y)    // '1.26e+501'\r\n   * x.times('-a', 16)               // '-6'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  times(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber negated, i.e. multiplied by -1.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.8)\r\n   * x.negated()                     // '-1.8'\r\n   * y = new BigNumber(-1.3)\r\n   * y.negated()                     // '1.3'\r\n   * ```\r\n   */\r\n  negated(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber plus `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.1 + 0.2                       // 0.30000000000000004\r\n   * x = new BigNumber(0.1)\r\n   * y = x.plus(0.2)                 // '0.3'\r\n   * BigNumber(0.7).plus(x).plus(y)  // '1.1'\r\n   * x.plus('0.1', 8)                // '0.225'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  plus(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns the number of significant digits of the value of this BigNumber, or `null` if the value\r\n   * of this BigNumber is ±`Infinity` or `NaN`.\r\n   *\r\n   * If `includeZeros` is true then any trailing zeros of the integer part of the value of this\r\n   * BigNumber are counted as significant digits, otherwise they are not.\r\n   *\r\n   * Throws if `includeZeros` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.precision()                         // 9\r\n   * y = new BigNumber(987000)\r\n   * y.precision(false)                    // 3\r\n   * y.precision(true)                     // 6\r\n   * ```\r\n   *\r\n   * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.\r\n   */\r\n  precision(includeZeros?: boolean): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of\r\n   * `significantDigits` significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.precision(6)                         // '9876.54'\r\n   * x.precision(6, BigNumber.ROUND_UP)     // '9876.55'\r\n   * x.precision(2)                         // '9900'\r\n   * x.precision(2, 1)                      // '9800'\r\n   * x                                      // '9876.54321'\r\n   * ```\r\n   *\r\n   * @param significantDigits Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  precision(significantDigits: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns the number of significant digits of the value of this BigNumber,\r\n   * or `null` if the value of this BigNumber is ±`Infinity` or `NaN`.\r\n   *\r\n   * If `includeZeros` is true then any trailing zeros of the integer part of\r\n   * the value of this BigNumber are counted as significant digits, otherwise\r\n   * they are not.\r\n   *\r\n   * Throws if `includeZeros` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.sd()                         // 9\r\n   * y = new BigNumber(987000)\r\n   * y.sd(false)                    // 3\r\n   * y.sd(true)                     // 6\r\n   * ```\r\n   *\r\n   * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.\r\n   */\r\n  sd(includeZeros?: boolean): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of\r\n   * `significantDigits` significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.sd(6)                           // '9876.54'\r\n   * x.sd(6, BigNumber.ROUND_UP)       // '9876.55'\r\n   * x.sd(2)                           // '9900'\r\n   * x.sd(2, 1)                        // '9800'\r\n   * x                                 // '9876.54321'\r\n   * ```\r\n   *\r\n   * @param significantDigits Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  sd(significantDigits: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber shifted by `n` places.\r\n   *\r\n   * The shift is of the decimal point, i.e. of powers of ten, and is to the left if `n` is negative\r\n   * or to the right if `n` is positive.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * Throws if `n` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.23)\r\n   * x.shiftedBy(3)                      // '1230'\r\n   * x.shiftedBy(-3)                     // '0.00123'\r\n   * ```\r\n   *\r\n   * @param n The shift value, integer, -9007199254740991 to 9007199254740991.\r\n   */\r\n  shiftedBy(n: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * The return value will be correctly rounded, i.e. rounded as if the result was first calculated\r\n   * to an infinite number of correct digits before rounding.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(16)\r\n   * x.squareRoot()                  // '4'\r\n   * y = new BigNumber(3)\r\n   * y.squareRoot()                  // '1.73205080756887729353'\r\n   * ```\r\n   */\r\n  squareRoot(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * The return value will be correctly rounded, i.e. rounded as if the result was first calculated\r\n   * to an infinite number of correct digits before rounding.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(16)\r\n   * x.sqrt()                  // '4'\r\n   * y = new BigNumber(3)\r\n   * y.sqrt()                  // '1.73205080756887729353'\r\n   * ```\r\n   */\r\n  sqrt(): BigNumber;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in exponential notation rounded using\r\n   * rounding mode `roundingMode` to `decimalPlaces` decimal places, i.e with one digit before the\r\n   * decimal point and `decimalPlaces` digits after it.\r\n   *\r\n   * If the value of this BigNumber in exponential notation has fewer than `decimalPlaces` fraction\r\n   * digits, the return value will be appended with zeros accordingly.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the number of digits after the\r\n   * decimal point defaults to the minimum number of digits necessary to represent the value\r\n   * exactly.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 45.6\r\n   * y = new BigNumber(x)\r\n   * x.toExponential()               // '4.56e+1'\r\n   * y.toExponential()               // '4.56e+1'\r\n   * x.toExponential(0)              // '5e+1'\r\n   * y.toExponential(0)              // '5e+1'\r\n   * x.toExponential(1)              // '4.6e+1'\r\n   * y.toExponential(1)              // '4.6e+1'\r\n   * y.toExponential(1, 1)           // '4.5e+1'  (ROUND_DOWN)\r\n   * x.toExponential(3)              // '4.560e+1'\r\n   * y.toExponential(3)              // '4.560e+1'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  toExponential(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toExponential(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in normal (fixed-point) notation\r\n   * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`.\r\n   *\r\n   * If the value of this BigNumber in normal notation has fewer than `decimalPlaces` fraction\r\n   * digits, the return value will be appended with zeros accordingly.\r\n   *\r\n   * Unlike `Number.prototype.toFixed`, which returns exponential notation if a number is greater or\r\n   * equal to 10**21, this method will always return normal notation.\r\n   *\r\n   * If `decimalPlaces` is omitted or is `null` or `undefined`, the return value will be unrounded\r\n   * and in normal notation. This is also unlike `Number.prototype.toFixed`, which returns the value\r\n   * to zero decimal places. It is useful when normal notation is required and the current\r\n   * `EXPONENTIAL_AT` setting causes `toString` to return exponential notation.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 3.456\r\n   * y = new BigNumber(x)\r\n   * x.toFixed()                     // '3'\r\n   * y.toFixed()                     // '3.456'\r\n   * y.toFixed(0)                    // '3'\r\n   * x.toFixed(2)                    // '3.46'\r\n   * y.toFixed(2)                    // '3.46'\r\n   * y.toFixed(2, 1)                 // '3.45'  (ROUND_DOWN)\r\n   * x.toFixed(5)                    // '3.45600'\r\n   * y.toFixed(5)                    // '3.45600'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  toFixed(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toFixed(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in normal (fixed-point) notation\r\n   * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`, and formatted\r\n   * according to the properties of the `format` or `FORMAT` object.\r\n   *\r\n   * The formatting object may contain some or all of the properties shown in the examples below.\r\n   *\r\n   * If `decimalPlaces` is omitted or is `null` or `undefined`, then the return value is not\r\n   * rounded to a fixed number of decimal places.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * If `format` is omitted or is `null` or `undefined`, `FORMAT` is used.\r\n   *\r\n   * Throws if `decimalPlaces`, `roundingMode`, or `format` is invalid.\r\n   *\r\n   * ```ts\r\n   * fmt = {\r\n   *   decimalSeparator: '.',\r\n   *   groupSeparator: ',',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   fractionGroupSeparator: ' ',\r\n   *   fractionGroupSize: 0\r\n   * }\r\n   *\r\n   * x = new BigNumber('123456789.123456789')\r\n   *\r\n   * // Set the global formatting options\r\n   * BigNumber.config({ FORMAT: fmt })\r\n   *\r\n   * x.toFormat()                              // '123,456,789.123456789'\r\n   * x.toFormat(3)                             // '123,456,789.123'\r\n   *\r\n   * // If a reference to the object assigned to FORMAT has been retained,\r\n   * // the format properties can be changed directly\r\n   * fmt.groupSeparator = ' '\r\n   * fmt.fractionGroupSize = 5\r\n   * x.toFormat()                              // '123 456 789.12345 6789'\r\n   *\r\n   * // Alternatively, pass the formatting options as an argument\r\n   * fmt = {\r\n   *   decimalSeparator: ',',\r\n   *   groupSeparator: '.',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 2\r\n   * }\r\n   *\r\n   * x.toFormat()                              // '123 456 789.12345 6789'\r\n   * x.toFormat(fmt)                           // '12.34.56.789,123456789'\r\n   * x.toFormat(2, fmt)                        // '12.34.56.789,12'\r\n   * x.toFormat(3, BigNumber.ROUND_UP, fmt)    // '12.34.56.789,124'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   * @param [format] Formatting options object. See `BigNumber.Format`.\r\n   */\r\n  toFormat(decimalPlaces: number, roundingMode: BigNumber.RoundingMode, format?: BigNumber.Format): string;\r\n  toFormat(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toFormat(decimalPlaces?: number): string;\r\n  toFormat(decimalPlaces: number, format: BigNumber.Format): string;\r\n  toFormat(format: BigNumber.Format): string;\r\n\r\n  /**\r\n   * Returns an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to `max_denominator`.\r\n   * If a maximum denominator, `max_denominator`, is not specified, or is `null` or `undefined`, the\r\n   * denominator will be the lowest value necessary to represent the number exactly.\r\n   *\r\n   * Throws if `max_denominator` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.75)\r\n   * x.toFraction()                  // '7, 4'\r\n   *\r\n   * pi = new BigNumber('3.14159265358')\r\n   * pi.toFraction()                 // '157079632679,50000000000'\r\n   * pi.toFraction(100000)           // '312689, 99532'\r\n   * pi.toFraction(10000)            // '355, 113'\r\n   * pi.toFraction(100)              // '311, 99'\r\n   * pi.toFraction(10)               // '22, 7'\r\n   * pi.toFraction(1)                // '3, 1'\r\n   * ```\r\n   *\r\n   * @param [max_denominator] The maximum denominator, integer > 0, or Infinity.\r\n   */\r\n  toFraction(max_denominator?: BigNumber.Value): [BigNumber, BigNumber];\r\n\r\n  /** As `valueOf`. */\r\n  toJSON(): string;\r\n\r\n  /**\r\n   * Returns the value of this BigNumber as a JavaScript primitive number.\r\n   *\r\n   * Using the unary plus operator gives the same result.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(456.789)\r\n   * x.toNumber()                    // 456.789\r\n   * +x                              // 456.789\r\n   *\r\n   * y = new BigNumber('45987349857634085409857349856430985')\r\n   * y.toNumber()                    // 4.598734985763409e+34\r\n   *\r\n   * z = new BigNumber(-0)\r\n   * 1 / z.toNumber()                // -Infinity\r\n   * 1 / +z                          // -Infinity\r\n   * ```\r\n   */\r\n  toNumber(): number;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber rounded to `significantDigits`\r\n   * significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `significantDigits` is less than the number of digits necessary to represent the integer\r\n   * part of the value in normal (fixed-point) notation, then exponential notation is used.\r\n   *\r\n   * If `significantDigits` is omitted, or is `null` or `undefined`, then the return value is the\r\n   * same as `n.toString()`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 45.6\r\n   * y = new BigNumber(x)\r\n   * x.toPrecision()                 // '45.6'\r\n   * y.toPrecision()                 // '45.6'\r\n   * x.toPrecision(1)                // '5e+1'\r\n   * y.toPrecision(1)                // '5e+1'\r\n   * y.toPrecision(2, 0)             // '4.6e+1'  (ROUND_UP)\r\n   * y.toPrecision(2, 1)             // '4.5e+1'  (ROUND_DOWN)\r\n   * x.toPrecision(5)                // '45.600'\r\n   * y.toPrecision(5)                // '45.600'\r\n   * ```\r\n   *\r\n   * @param [significantDigits] Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer 0 to 8.\r\n   */\r\n  toPrecision(significantDigits: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toPrecision(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in base `base`, or base 10 if `base`\r\n   * is omitted or is `null` or `undefined`.\r\n   *\r\n   * For bases above 10, and using the default base conversion alphabet (see `ALPHABET`), values\r\n   * from 10 to 35 are represented by a-z (the same as `Number.prototype.toString`).\r\n   *\r\n   * If a base is specified the value is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings, otherwise it is not.\r\n   *\r\n   * If a base is not specified, and this BigNumber has a positive exponent that is equal to or\r\n   * greater than the positive component of the current `EXPONENTIAL_AT` setting, or a negative\r\n   * exponent equal to or less than the negative component of the setting, then exponential notation\r\n   * is returned.\r\n   *\r\n   * If `base` is `null` or `undefined` it is ignored.\r\n   *\r\n   * Throws if `base` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(750000)\r\n   * x.toString()                    // '750000'\r\n   * BigNumber.config({ EXPONENTIAL_AT: 5 })\r\n   * x.toString()                    // '7.5e+5'\r\n   *\r\n   * y = new BigNumber(362.875)\r\n   * y.toString(2)                   // '101101010.111'\r\n   * y.toString(9)                   // '442.77777777777777777778'\r\n   * y.toString(32)                  // 'ba.s'\r\n   *\r\n   * BigNumber.config({ DECIMAL_PLACES: 4 });\r\n   * z = new BigNumber('1.23456789')\r\n   * z.toString()                    // '1.23456789'\r\n   * z.toString(10)                  // '1.2346'\r\n   * ```\r\n   *\r\n   * @param [base] The base, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).\r\n   */\r\n  toString(base?: number): string;\r\n\r\n  /**\r\n   * As `toString`, but does not accept a base argument and includes the minus sign for negative\r\n   * zero.\r\n   *\r\n   * ``ts\r\n   * x = new BigNumber('-0')\r\n   * x.toString()                    // '0'\r\n   * x.valueOf()                     // '-0'\r\n   * y = new BigNumber('1.777e+457')\r\n   * y.valueOf()                     // '1.777e+457'\r\n   * ```\r\n   */\r\n  valueOf(): string;\r\n\r\n  /** Helps ES6 import. */\r\n  private static readonly default?: BigNumber.Constructor;\r\n\r\n  /** Helps ES6 import. */\r\n  private static readonly BigNumber?: BigNumber.Constructor;\r\n\r\n  /** Rounds away from zero. */\r\n  static readonly ROUND_UP: 0;\r\n\r\n  /** Rounds towards zero. */\r\n  static readonly ROUND_DOWN: 1;\r\n\r\n  /** Rounds towards Infinity. */\r\n  static readonly ROUND_CEIL: 2;\r\n\r\n  /** Rounds towards -Infinity. */\r\n  static readonly ROUND_FLOOR: 3;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds away from zero . */\r\n  static readonly ROUND_HALF_UP: 4;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards zero. */\r\n  static readonly ROUND_HALF_DOWN: 5;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards even neighbour. */\r\n  static readonly ROUND_HALF_EVEN: 6;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards Infinity. */\r\n  static readonly ROUND_HALF_CEIL: 7;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards -Infinity. */\r\n  static readonly ROUND_HALF_FLOOR: 8;\r\n\r\n  /** See `MODULO_MODE`. */\r\n  static readonly EUCLID: 9;\r\n\r\n  /**\r\n   * To aid in debugging, if a `BigNumber.DEBUG` property is `true` then an error will be thrown\r\n   * if the BigNumber constructor receives an invalid `BigNumber.Value`, or if `BigNumber.isBigNumber`\r\n   * receives a BigNumber instance that is malformed.\r\n   *\r\n   * ```ts\r\n   * // No error, and BigNumber NaN is returned.\r\n   * new BigNumber('blurgh')    // 'NaN'\r\n   * new BigNumber(9, 2)        // 'NaN'\r\n   * BigNumber.DEBUG = true\r\n   * new BigNumber('blurgh')    // '[BigNumber Error] Not a number'\r\n   * new BigNumber(9, 2)        // '[BigNumber Error] Not a base 2 number'\r\n   * ```\r\n   *\r\n   * An error will also be thrown if a `BigNumber.Value` is of type number with more than 15\r\n   * significant digits, as calling `toString` or `valueOf` on such numbers may not result\r\n   * in the intended value.\r\n   *\r\n   * ```ts\r\n   * console.log(823456789123456.3)       //  823456789123456.2\r\n   * // No error, and the returned BigNumber does not have the same value as the number literal.\r\n   * new BigNumber(823456789123456.3)     // '823456789123456.2'\r\n   * BigNumber.DEBUG = true\r\n   * new BigNumber(823456789123456.3)\r\n   * // '[BigNumber Error] Number primitive has more than 15 significant digits'\r\n   * ```\r\n   *\r\n   * Check that a BigNumber instance is well-formed:\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(10)\r\n   *\r\n   * BigNumber.DEBUG = false\r\n   * // Change x.c to an illegitimate value.\r\n   * x.c = NaN\r\n   * // No error, as BigNumber.DEBUG is false.\r\n   * BigNumber.isBigNumber(x)    // true\r\n   *\r\n   * BigNumber.DEBUG = true\r\n   * BigNumber.isBigNumber(x)    // '[BigNumber Error] Invalid BigNumber'\r\n   * ```\r\n   */\r\n  static DEBUG?: boolean;\r\n\r\n  /**\r\n   * Returns a new independent BigNumber constructor with configuration as described by `object`, or\r\n   * with the default configuration if object is `null` or `undefined`.\r\n   *\r\n   * Throws if `object` is not an object.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n   * BN = BigNumber.clone({ DECIMAL_PLACES: 9 })\r\n   *\r\n   * x = new BigNumber(1)\r\n   * y = new BN(1)\r\n   *\r\n   * x.div(3)                        // 0.33333\r\n   * y.div(3)                        // 0.333333333\r\n   *\r\n   * // BN = BigNumber.clone({ DECIMAL_PLACES: 9 }) is equivalent to:\r\n   * BN = BigNumber.clone()\r\n   * BN.config({ DECIMAL_PLACES: 9 })\r\n   * ```\r\n   *\r\n   * @param [object] The configuration object.\r\n   */\r\n  static clone(object?: BigNumber.Config): BigNumber.Constructor;\r\n\r\n  /**\r\n   * Configures the settings that apply to this BigNumber constructor.\r\n   *\r\n   * The configuration object, `object`, contains any number of the properties shown in the example\r\n   * below.\r\n   *\r\n   * Returns an object with the above properties and their current values.\r\n   *\r\n   * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the\r\n   * properties.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({\r\n   *     DECIMAL_PLACES: 40,\r\n   *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,\r\n   *     EXPONENTIAL_AT: [-10, 20],\r\n   *     RANGE: [-500, 500],\r\n   *     CRYPTO: true,\r\n   *     MODULO_MODE: BigNumber.ROUND_FLOOR,\r\n   *     POW_PRECISION: 80,\r\n   *     FORMAT: {\r\n   *         groupSize: 3,\r\n   *         groupSeparator: ' ',\r\n   *         decimalSeparator: ','\r\n   *     },\r\n   *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n   * });\r\n   *\r\n   * BigNumber.config().DECIMAL_PLACES        // 40\r\n   * ```\r\n   *\r\n   * @param object The configuration object.\r\n   */\r\n  static config(object?: BigNumber.Config): BigNumber.Config;\r\n\r\n  /**\r\n   * Returns `true` if `value` is a BigNumber instance, otherwise returns `false`.\r\n   *\r\n   * If `BigNumber.DEBUG` is `true`, throws if a BigNumber instance is not well-formed.\r\n   *\r\n   * ```ts\r\n   * x = 42\r\n   * y = new BigNumber(x)\r\n   *\r\n   * BigNumber.isBigNumber(x)             // false\r\n   * y instanceof BigNumber               // true\r\n   * BigNumber.isBigNumber(y)             // true\r\n   *\r\n   * BN = BigNumber.clone();\r\n   * z = new BN(x)\r\n   * z instanceof BigNumber               // false\r\n   * BigNumber.isBigNumber(z)             // true\r\n   * ```\r\n   *\r\n   * @param value The value to test.\r\n   */\r\n  static isBigNumber(value: any): value is BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.maximum(4e9, x, '123456789.9')      // '4000000000'\r\n   *\r\n   * arr = [12, '13', new BigNumber(14)]\r\n   * BigNumber.maximum.apply(null, arr)            // '14'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static maximum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.max(4e9, x, '123456789.9')      // '4000000000'\r\n   *\r\n   * arr = [12, '13', new BigNumber(14)]\r\n   * BigNumber.max.apply(null, arr)            // '14'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static max(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.minimum(4e9, x, '123456789.9')          // '123456789.9'\r\n   *\r\n   * arr = [2, new BigNumber(-14), '-15.9999', -12]\r\n   * BigNumber.minimum.apply(null, arr)                // '-15.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static minimum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.min(4e9, x, '123456789.9')             // '123456789.9'\r\n   *\r\n   * arr = [2, new BigNumber(-14), '-15.9999', -12]\r\n   * BigNumber.min.apply(null, arr)                   // '-15.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static min(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a new BigNumber with a pseudo-random value equal to or greater than 0 and less than 1.\r\n   *\r\n   * The return value will have `decimalPlaces` decimal places, or less if trailing zeros are\r\n   * produced. If `decimalPlaces` is omitted, the current `DECIMAL_PLACES` setting will be used.\r\n   *\r\n   * Depending on the value of this BigNumber constructor's `CRYPTO` setting and the support for the\r\n   * `crypto` object in the host environment, the random digits of the return value are generated by\r\n   * either `Math.random` (fastest), `crypto.getRandomValues` (Web Cryptography API in recent\r\n   * browsers) or `crypto.randomBytes` (Node.js).\r\n   *\r\n   * To be able to set `CRYPTO` to true when using Node.js, the `crypto` object must be available\r\n   * globally:\r\n   *\r\n   * ```ts\r\n   * global.crypto = require('crypto')\r\n   * ```\r\n   *\r\n   * If `CRYPTO` is true, i.e. one of the `crypto` methods is to be used, the value of a returned\r\n   * BigNumber should be cryptographically secure and statistically indistinguishable from a random\r\n   * value.\r\n   *\r\n   * Throws if `decimalPlaces` is invalid.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 10 })\r\n   * BigNumber.random()              // '0.4117936847'\r\n   * BigNumber.random(20)            // '0.78193327636914089009'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   */\r\n  static random(decimalPlaces?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.sum(4e9, x, '123456789.9')      // '7381326134.9378653'\r\n   *\r\n   * arr = [2, new BigNumber(14), '15.9999', 12]\r\n   * BigNumber.sum.apply(null, arr)            // '43.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static sum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Configures the settings that apply to this BigNumber constructor.\r\n   *\r\n   * The configuration object, `object`, contains any number of the properties shown in the example\r\n   * below.\r\n   *\r\n   * Returns an object with the above properties and their current values.\r\n   *\r\n   * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the\r\n   * properties.\r\n   *\r\n   * ```ts\r\n   * BigNumber.set({\r\n   *     DECIMAL_PLACES: 40,\r\n   *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,\r\n   *     EXPONENTIAL_AT: [-10, 20],\r\n   *     RANGE: [-500, 500],\r\n   *     CRYPTO: true,\r\n   *     MODULO_MODE: BigNumber.ROUND_FLOOR,\r\n   *     POW_PRECISION: 80,\r\n   *     FORMAT: {\r\n   *         groupSize: 3,\r\n   *         groupSeparator: ' ',\r\n   *         decimalSeparator: ','\r\n   *     },\r\n   *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n   * });\r\n   *\r\n   * BigNumber.set().DECIMAL_PLACES        // 40\r\n   * ```\r\n   *\r\n   * @param object The configuration object.\r\n   */\r\n  static set(object?: BigNumber.Config): BigNumber.Config;\r\n}\r\n\r\nexport function BigNumber(n: BigNumber.Value, base?: number): BigNumber;\r\n"
}